<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="/favicon.ico">

  <title>
    Reverse Engineering a Smart Contract - Security Pills
  </title>

  <meta name="description" content="Image courtesy of OpenZeppelin
Reverse Engineering a smart-contract NTM: Write an introductory paragraph here
Verified contracts on Etherscan Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.
For instance, using a testing smart contract deployed at address 0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1 in the Goerli network, we could easily recover its source code by checking the Contract tab in Ethernaut:" /><meta name="generator" content="Hugo 0.109.0">

  <link rel="stylesheet" href="https://securitypills.github.io/css/main.css" />

  
  

  <meta property="og:title" content="Reverse Engineering a Smart Contract" />
<meta property="og:description" content="Image courtesy of OpenZeppelin
Reverse Engineering a smart-contract NTM: Write an introductory paragraph here
Verified contracts on Etherscan Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.
For instance, using a testing smart contract deployed at address 0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1 in the Goerli network, we could easily recover its source code by checking the Contract tab in Ethernaut:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://securitypills.github.io/articles/reverse-engineering-a-smart-contract/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2022-11-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-11-28T00:00:00+00:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Reverse Engineering a Smart Contract"/>
<meta name="twitter:description" content="Image courtesy of OpenZeppelin
Reverse Engineering a smart-contract NTM: Write an introductory paragraph here
Verified contracts on Etherscan Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.
For instance, using a testing smart contract deployed at address 0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1 in the Goerli network, we could easily recover its source code by checking the Contract tab in Ethernaut:"/>


  <meta itemprop="name" content="Reverse Engineering a Smart Contract">
<meta itemprop="description" content="Image courtesy of OpenZeppelin
Reverse Engineering a smart-contract NTM: Write an introductory paragraph here
Verified contracts on Etherscan Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.
For instance, using a testing smart contract deployed at address 0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1 in the Goerli network, we could easily recover its source code by checking the Contract tab in Ethernaut:"><meta itemprop="datePublished" content="2022-11-28T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-11-28T00:00:00+00:00" />
<meta itemprop="wordCount" content="2170">
<meta itemprop="keywords" content="" />

  <meta itemprop="name" content="Reverse Engineering a Smart Contract">
<meta itemprop="description" content="Image courtesy of OpenZeppelin
Reverse Engineering a smart-contract NTM: Write an introductory paragraph here
Verified contracts on Etherscan Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.
For instance, using a testing smart contract deployed at address 0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1 in the Goerli network, we could easily recover its source code by checking the Contract tab in Ethernaut:"><meta itemprop="datePublished" content="2022-11-28T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-11-28T00:00:00+00:00" />
<meta itemprop="wordCount" content="2170">
<meta itemprop="keywords" content="" />
</head><body class="flex relative h-full min-h-screen"><aside
  class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:w-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar">
  <p class="font-bold mb-5 flex items-center gap-2">
    <button
      aria-label="Close sidebar"
      class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg></button>
    <a href="https://securitypills.github.io/" class="px-2">
    <span>Security Pills</span>
    
    </a>
    
    <button
      aria-label="Toggle dark mode"
      class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <circle cx="12" cy="12" r="4" />
  <path d="M3 12h1M12 3v1M20 12h1M12 20v1M5.6 5.6l.7 .7M18.4 5.6l-.7 .7M17.7 17.7l.7 .7M6.3 17.7l-.7 .7" />
</svg></button>
  
  </p>

  
  <ul class="list-none flex flex-col gap-1">
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/" >
        <span>Home</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles" >
        <span>Blog</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/portfolio" >
        <span>Newsletter</span>
        
      </a>
    </li>
    
  </ul>

  <div class="flex-1"></div>

  <div class="revue-widget">
  <form action="https://embeds.beehiiv.com/3645f86f-e3bb-46cb-adec-b3b2f20c9411?slim=true" method="post" name="revue-form" target="_blank">
    <div class="text-bold text-sm">Subscribe to my newsletter</div>
    
    <p class="text-xs my-1 text-slate-500">A weekly newsletter for smart and curious people interested in security, technology, and smartcontracts</p>
    
    <div class="mt-2">
      <input type="email" class="w-full px-1.5 py-0.5 text-sm rounded border dark:border-slate-700 dark:bg-slate-600" name="member[email]" id="member_email" placeholder="Your email address...">
      <input type="submit" class="mt-2 w-full text-center text-sm bg-slate-800 text-white dark:bg-slate-50 dark:text-slate-800 py-1 rounded" name="member[subscribe]" id="member_submit" value="Subscribe">
    </div>
  </form>
</div>

  <ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600">
    
  </ul>
</aside>

<div
  class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay">
</div>

<button
  aria-label="Toggle Sidebar"
  class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <line x1="4" y1="6" x2="20" y2="6" />
  <line x1="4" y1="12" x2="20" y2="12" />
  <line x1="4" y1="18" x2="16" y2="18" />
</svg></button><div class="flex-1">



<div class="flex h-screen relative">

  <section
    class="will-change-transform transform transition-transform -translate-x-[200%] absolute top-0 left-0 lg:relative
  lg:translate-x-0 lg:min-w-[400px] lg:w-1/4 h-full bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 lg:flex flex-col py-3 overflow-y-auto scroll-area">
    
    
    <a href="https://securitypills.github.io/articles/">
      <h2 class="font-bold mb-5 py-1 pl-12 pr-3 md:px-3">Articles</h2>
    </a>
    <div class="space-y-2.5">
      
      <a class="block px-3 py-4  bg-slate-900 dark:bg-slate-700 text-slate-50 "
        href="/articles/reverse-engineering-a-smart-contract/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Reverse Engineering a Smart Contract</h3>
        <div
          class="text-sm  text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Reverse Engineering a smart-contract NTM: Write an introductory paragraph here
Verified contracts on Etherscan Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.
For instance, using a testing smart contract deployed at address 0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1 in the Goerli network, we could easily recover its source code by checking the Contract tab in Ethernaut:
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-7-force/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 07 - Force</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 07 - Force This level from Ethernaut, Force, provides us with an empty smart contract containing only some ASCII-art. The goal here is to send some ether to the contract using the selfdestruct() instruction.
# Level 07 - Force ### Source Code // SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =Ã¸= / (______)__m_m) */} Before explaining why this smart contract is vulnerable, let&rsquo;s get familiarized with the function selfdestruct().
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-6-delegation/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 06 - Delegation</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 06 - Delegation This level from Ethernaut, Delegation, is about a special Solidity method called delegatecall(). To complete this level, we must understand how this low level function works, how it can be used to delegate operations to on-chain libraries, and what implications it has on execution scope.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-5-token/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 05 - Token</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 05 - Token This level from Ethernaut, called Token, is a good exercise to become familiar with the integer underflow and integer overflow concepts. In this challenge you are given 20 tokens to start with and you will beat the level if you somehow manage to get your hands on any additional tokens. Preferably a very large number of tokens.
// SPDX-License-Identifier: MIT pragma solidity ^0.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-4-telephone/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 04 - Telephone</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 04 - Telephone This level from Ethernaut, called Telephone, is a good exercise to learn the nuances between tx.origin and msg.sender and why you should never use tx.origin for authentication purposes:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } Solidity has a global variable, tx.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-3-coinflip/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 03 - Coinflip</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 03 - Coinflip The third level in Ethernaut, CoinFlip, is a good exercise that will teach you how to exploit pseudo randomness implementations in smart contracts. This contract will require you to correctly guess the outcome of a coin flip ten times in a row:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut Challenges</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Please read This is a work in progress article that will receive updates as we continue publishing detailed walkthroughs for each level.
Ethernaut is OpenZeppelin Web3/Solidity based wargame to learn about Ethereum smart contract security and become familiar with programming principles in Solidity.
Although the game was launched few years ago it has become a good place to start for those who are interested on security and smart contracts.
Challenges are currently running on the Rinkeby testnet and you will require to use a Rinkey Faucet to get free testnet ETH and test the smart contracts.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-1-fallback/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 01 - Fallback</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 01 - Fallback The first level from Ethernaut is pretty straightforward and we will use it to become familiar with some Solidity concepts and the Brownie framework that we will use to complete this challenge.
The code for the smart contract that we must exploit is shown above:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;; contract Fallback { using SafeMath for uint256; mapping(address =&gt; uint) public contributions; address payable public owner; constructor() public { owner = msg.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/ethernaut-2-fallout/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Ethernaut - Level 02 - Fallout</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Image courtesy of OpenZeppelin
Ethernaut 02 - Fallout The goal for this level is to claim ownership of the contract, which has the following implementation:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;; contract Fallout { using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, &#34;caller is not the owner&#34; ); _; } function allocate() public payable { allocations[msg.
        </div>
      </a>
      </div>
    </section>

  <div class="overflow-y-auto h-screen w-full">
    <article class="px-6 py-20 w-full mx-auto prose lg:prose-lg h-fit dark:prose-invert prose-img:mx-auto">

      
      <h1 class="!mb-2">Reverse Engineering a Smart Contract</h1>
      
      <p class="text-sm text-slate-500 !mb-8">November 28, 2022</p>
      

      

      <figure><img src="../images/force-7.png"
         alt="Image courtesy of OpenZeppelin"/><figcaption>
            <p>Image courtesy of OpenZeppelin</p>
        </figcaption>
</figure>

<h1 id="reverse-engineering-a-smart-contract">Reverse Engineering a smart-contract</h1>
<p>NTM: Write an introductory paragraph here</p>
<h3 id="verified-contracts-on-etherscan">Verified contracts on Etherscan</h3>
<p>Everything in the blockchain is verifiable, consistent and can be publicly accessible. Every smart contract should have their source code published and verified in Etherscan, or any other blockchain used for its deployment.</p>
<p>For instance, using a testing smart contract deployed at address <code>0x4cD4AD48e22EdfC8a43B8cb26d0Ac9ceeB9E75f1</code> in the <code>Goerli</code> network, we could easily recover its source code by checking the <strong>Contract</strong> tab in Ethernaut:</p>
<figure><img src="../images/sc-etherscan-1.png"
         alt="Figure 1 - Contract tab on Etherscan"/><figcaption>
            <p>Figure 1 - Contract tab on Etherscan</p>
        </figcaption>
</figure>

<p>With this information we could now use our favorite IDE to inspect the contract&rsquo;s implementation and start our analysis.</p>
<h3 id="bytecode-decompilation">Bytecode decompilation</h3>
<p>However, there may be scenarios where a smart contract does not have published or verified its source code, and we will be required to reverse engineer a contract by looking at its EVM bytecode.</p>
<p>For example, lets assume the following EVM bytecode for one of the contracts that we have published in the Goerli network and there is no source code published:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063423f6cef1161005b578063423f6cef146100dc57806370a082311461010c57806395d89b411461013c578063b9c134771461015a5761007d565b806306fdde031461008257806318160ddd146100a0578063313ce567146100be575b600080fd5b61008a61018a565b60405161009791906105eb565b60405180910390f35b6100a861021c565b6040516100b5919061060d565b60405180910390f35b6100c6610226565b6040516100d39190610628565b60405180910390f35b6100f660048036038101906100f1919061052e565b61022f565b60405161010391906105d0565b60405180910390f35b61012660048036038101906101219190610505565b610321565b604051610133919061060d565b60405180910390f35b610144610369565b60405161015191906105eb565b60405180910390f35b610174600480360381019061016f919061052e565b6103fb565b60405161018191906105d0565b60405180910390f35b60606003805461019990610771565b80601f01602080910402602001604051908101604052809291908181526020018280546101c590610771565b80156102125780601f106101e757610100808354040283529160200191610212565b820191906000526020600020905b8154815290600101906020018083116101f557829003601f168201915b5050505050905090565b6000600254905090565b60006012905090565b6000806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050828161027f91906106b5565b6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461030f919061065f565b92505081905550600191505092915050565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60606004805461037890610771565b80601f01602080910402602001604051908101604052809291908181526020018280546103a490610771565b80156103f15780601f106103c6576101008083540402835291602001916103f1565b820191906000526020600020905b8154815290600101906020018083116103d457829003601f168201915b5050505050905090565b6000806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508281036000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550600191505092915050565b6000813590506104ea81610812565b92915050565b6000813590506104ff81610829565b92915050565b60006020828403121561051757600080fd5b6000610525848285016104db565b91505092915050565b6000806040838503121561054157600080fd5b600061054f858286016104db565b9250506020610560858286016104f0565b9150509250929050565b610573816106fb565b82525050565b600061058482610643565b61058e818561064e565b935061059e81856020860161073e565b6105a781610801565b840191505092915050565b6105bb81610727565b82525050565b6105ca81610731565b82525050565b60006020820190506105e5600083018461056a565b92915050565b600060208201905081810360008301526106058184610579565b905092915050565b600060208201905061062260008301846105b2565b92915050565b600060208201905061063d60008301846105c1565b92915050565b600081519050919050565b600082825260208201905092915050565b600061066a82610727565b915061067583610727565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156106aa576106a96107a3565b5b828201905092915050565b60006106c082610727565b91506106cb83610727565b9250828210156106de576106dd6107a3565b5b828203905092915050565b60006106f482610707565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600060ff82169050919050565b60005b8381101561075c578082015181840152602081019050610741565b8381111561076b576000848401525b50505050565b6000600282049050600182168061078957607f821691505b6020821081141561079d5761079c6107d2565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000601f19601f8301169050919050565b61081b816106e9565b811461082657600080fd5b50565b61083281610727565b811461083d57600080fd5b5056fea26469706673582212204ad696d4ca54f78e728c33a6cfa047d978e4d8e8bd34bc381af14bbe4148be1064736f6c63430008040033
</span></span></code></pre></div><p>If we map all the opcodes above into readable instructions, we will get the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>00: <span style="color:#ae81ff">6080</span> PUSH1 0x80 
</span></span><span style="display:flex;"><span>02: <span style="color:#ae81ff">6040</span> PUSH1 0x40 
</span></span><span style="display:flex;"><span>04: <span style="color:#ae81ff">52</span> MSTORE
</span></span><span style="display:flex;"><span>...omitted <span style="color:#66d9ef">for</span> brevity...
</span></span></code></pre></div><p>From above code snippet, we can see 2 opcodes, <code>PUSH1</code> and <code>MSTORE</code>. The opcode <code>PUSH1</code> pushes 1-byte integer into the stack for future use (In the EVM, integers are range from 1-byte to 32-byte long, using <code>PUSH1</code>, <code>PUSH2</code>, &hellip; , <code>PUSH32</code>, respectively, as opcodes). In this case it pushes <code>0x80</code> and <code>0x40</code> into the stack, then use the <code>MSTORE</code> opcode which takes the two items in the stack and performs a memory write operation (<code>MSTORE(0x40, 0x80)</code>). But let&rsquo;s just not focus on reversing opcodes for now.</p>
<p>Etherscan provides a functionality to represent EVM bytecode into their respective opcodes, by clicking on the <strong>Switch To Opcodes View</strong> button:</p>
<figure><img src="../images/sc-etherscan-2.png"
         alt="Figure 3 - Smart contract bytecode view"/><figcaption>
            <p>Figure 3 - Smart contract bytecode view</p>
        </figcaption>
</figure>

<p>This will result in an output that should match with the EVM bytecode presented few lines above:</p>
<figure><img src="../images/sc-etherscan-3.png"
         alt="Figure 3 - Smart contract opcodes view"/><figcaption>
            <p>Figure 3 - Smart contract opcodes view</p>
        </figcaption>
</figure>

<p>Additionally, you can use a EVM decompiler like <a href="https://github.com/palkeo/panoramix"  target="_blank" rel="noopener" >panoramix</a> (same one used by Etherscan and palkeo, among others) to decompile the EVM bytecode and obtain an approximation to the original smart contract source code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>root@vmi828562 ~# panoramix 0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063423f6cef1161005b578063423f6cef146100dc57806370a082311461010c57806395d89b411461013c578063b9c134771461015a5761007d565b806306fdde031461008257806318160ddd146100a0578063313ce567146100be575b600080fd5b61008a61018a565b60405161009791906105eb565b60405180910390f35b6100a861021c565b6040516100b5919061060d565b60405180910390f35b6100c6610226565b6040516100d39190610628565b60405180910390f35b6100f660048036038101906100f1919061052e565b61022f565b60405161010391906105d0565b60405180910390f35b61012660048036038101906101219190610505565b610321565b604051610133919061060d565b60405180910390f35b610144610369565b60405161015191906105eb565b60405180910390f35b610174600480360381019061016f919061052e565b6103fb565b60405161018191906105d0565b60405180910390f35b60606003805461019990610771565b80601f01602080910402602001604051908101604052809291908181526020018280546101c590610771565b80156102125780601f106101e757610100808354040283529160200191610212565b820191906000526020600020905b8154815290600101906020018083116101f557829003601f168201915b5050505050905090565b6000600254905090565b60006012905090565b6000806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050828161027f91906106b5565b6000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461030f919061065f565b92505081905550600191505092915050565b60008060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60606004805461037890610771565b80601f01602080910402602001604051908101604052809291908181526020018280546103a490610771565b80156103f15780601f106103c6576101008083540402835291602001916103f1565b820191906000526020600020905b8154815290600101906020018083116103d457829003601f168201915b5050505050905090565b6000806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490508281036000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550826000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550600191505092915050565b6000813590506104ea81610812565b92915050565b6000813590506104ff81610829565b92915050565b60006020828403121561051757600080fd5b6000610525848285016104db565b91505092915050565b6000806040838503121561054157600080fd5b600061054f858286016104db565b9250506020610560858286016104f0565b9150509250929050565b610573816106fb565b82525050565b600061058482610643565b61058e818561064e565b935061059e81856020860161073e565b6105a781610801565b840191505092915050565b6105bb81610727565b82525050565b6105ca81610731565b82525050565b60006020820190506105e5600083018461056a565b92915050565b600060208201905081810360008301526106058184610579565b905092915050565b600060208201905061062260008301846105b2565b92915050565b600060208201905061063d60008301846105c1565b92915050565b600081519050919050565b600082825260208201905092915050565b600061066a82610727565b915061067583610727565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156106aa576106a96107a3565b5b828201905092915050565b60006106c082610727565b91506106cb83610727565b9250828210156106de576106dd6107a3565b5b828203905092915050565b60006106f482610707565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600060ff82169050919050565b60005b8381101561075c578082015181840152602081019050610741565b8381111561076b576000848401525b50505050565b6000600282049050600182168061078957607f821691505b6020821081141561079d5761079c6107d2565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000601f19601f8301169050919050565b61081b816106e9565b811461082657600080fd5b50565b61083281610727565b811461083d57600080fd5b5056fea26469706673582212204ad696d4ca54f78e728c33a6cfa047d978e4d8e8bd34bc381af14bbe4148be1064736f6c63430008040033
</span></span></code></pre></div><p>Resulting in the following code</p>
<h2 id="installing-ghidra">Installing Ghidra</h2>
<p>The purpose of this section is to go over the installation and configuration of Ghidra and the <code>ghidra-evm</code> plugin. Which will help us throughout the reverse engineering process.</p>
<ul>
<li>Install <a href="https://github.com/NationalSecurityAgency/ghidra/releases/tag/Ghidra_9.1.2_build"  target="_blank" rel="noopener" >Ghidra 9.1.2</a></li>
<li>Install OpenJDK-11: <code>sudo apt install openjdk-11-jdk</code></li>
<li>Install the <code>ghidra-bridge</code> plugin: <code>python3 -m pip install ghidra-bridge</code></li>
<li>Install the <code>ghidra-bridge</code> server: <code>python3 -m ghidra_bridge.install_server ~/ghidra_scripts</code></li>
<li>Install the <code>evm-cfg-builder</code> tool used to extract a control flow graph (CFG) from EVM bytecode: <code>python3 -m pip install evm-cfg-builder</code></li>
<li>Clone the <a href="https://github.com/adelapie/ghidra-evm"  target="_blank" rel="noopener" >Ghidra EVM module</a> for reverse engineering smart contracts: <code>git clone https://github.com/adelapie/ghidra-evm.git ~/ghidra-evm</code></li>
</ul>
<p>The next step will be to install the Ghidra EVM Module, by opening Ghidra, and then accessing <code>File</code> &gt; <code>Install Extensions...</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>python3 ~/ghidra-evm/helper/evm_helper.py ~/smart_contract_security/int_overflow_ghidra/compiled_contract.evm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       _     _     _
</span></span><span style="display:flex;"><span>  __ _| |__ <span style="color:#f92672">(</span>_<span style="color:#f92672">)</span> __| |_ __ __ _        _____   ___ __ ___
</span></span><span style="display:flex;"><span> / _<span style="color:#e6db74">`</span> | <span style="color:#e6db74">&#39;_ \| |/ _` | &#39;</span>__/ _<span style="color:#e6db74">`</span> |_____ / _ <span style="color:#ae81ff">\ \ </span>/ / <span style="color:#e6db74">&#39;_ ` _ \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">| (_| | | | | | (_| | | | (_| |_____|  __/\ V /| | | | | |
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> \__, |_| |_|_|\__,_|_|  \__,_|      \___| \_/ |_| |_| |_| v.0.1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> |___/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[*] Parsing bytecode...
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">b&#39;</span>608060405234801561001057600080fd5b506004361061007d5760003560e01c8063423f6cef1161005b578063423f6cef146100dc57806370a082311461010c57806395d89b411461013c578063b9c134771461015a576100
</span></span><span style="display:flex;"><span>...omitted <span style="color:#66d9ef">for</span> brevity...
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Setting analysis options....
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Creating CFG...
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Resolving jumps...
</span></span><span style="display:flex;"><span>&lt;cfg BasicBlock@795-79b&gt;
</span></span><span style="display:flex;"><span>Finishes at:  0x79b
</span></span><span style="display:flex;"><span>	JUMP to: 0x7d2
</span></span><span style="display:flex;"><span>&lt;cfg BasicBlock@10-19&gt;
</span></span><span style="display:flex;"><span>Finishes at:  0x19
</span></span><span style="display:flex;"><span>	JUMPI to:  0x7d
</span></span><span style="display:flex;"><span>&lt;cfg BasicBlock@a0-a7&gt;
</span></span><span style="display:flex;"><span>Finishes at:  0xa7
</span></span><span style="display:flex;"><span>	JUMP to: 0x21c
</span></span></code></pre></div><figure><img src="../images/sc-ghidra-1.png"
         alt="Figure 4 - Enabling Ghidra Bridge"/><figcaption>
            <p>Figure 4 - Enabling Ghidra Bridge</p>
        </figcaption>
</figure>

<figure><img src="../images/sc-ghidra-2.png"
         alt="Figure 5 - Opcodes parsed correctly"/><figcaption>
            <p>Figure 5 - Opcodes parsed correctly</p>
        </figcaption>
</figure>

<figure><img src="../images/sc-ghidra-3.png"
         alt="Figure 5 - Control flow graph (CFG)"/><figcaption>
            <p>Figure 5 - Control flow graph (CFG)</p>
        </figcaption>
</figure>

<h2 id="reverse-engineering-process">Reverse Engineering process</h2>
<p>unctions Signatures (4byte identifiers) / Functions name &amp; arguments type recovery
&ndash; Complete this, services that maintain a databse where you can provide a 4bytes signature and get the function&rsquo;s body.
<a href="https://www.4byte.directory/"  target="_blank" rel="noopener" >https://www.4byte.directory/</a></p>
<p><code>explorer.web3_sha3('0x'+'FUNCTION'.encode(&quot;utf-8&quot;).hex())</code></p>
<ul>
<li><code>0x423f6cef</code> - <code>safeTransfer(address, uint256)</code></li>
<li><code>0x70a08231</code> - <code>balanceOf(address)</code></li>
<li><code>0x95d89b41</code> - <code>symbol()</code></li>
<li><code>0xb9c13477</code> - No signature available, although this one belongs to <code>unsafeTransfer(address, uint256)</code></li>
<li><code>0x06fdde03</code> - <code>name()</code></li>
<li><code>0x18160ddd</code> - <code>totalSupply()</code></li>
<li><code>0x313ce567</code> - <code>decimals()</code></li>
</ul>
<p>Reason why there could be multiple matches for a signature is due to a hash collision, as we are just using the first 4 bytes.
Probably best approach is tu use panoramix</p>
<h3 id="diagram">Diagram</h3>
<ul>
<li>sol2umc / standalon + etherscan</li>
<li></li>
</ul>
<h3 id="dispatcher-function">Dispatcher function</h3>
<p>When you perform a transaction to a smart contract, the first piece of code your transaction will interact with is the contract&rsquo;s dispatcher. The dispatcher takes your transaction data and determines which function are you trying to interact with.</p>
<p>The first thing we will notice with the dispatcher function in this contract is a check to determine if <code>msg.value</code> is zero, if so, we will revert the transaction:</p>
<figure><img src="../images/sc-re-1.png"
         alt="Figure 6 - CFG for dispatcher function"/><figcaption>
            <p>Figure 6 - CFG for dispatcher function</p>
        </figcaption>
</figure>

<blockquote>
<p>This behavior corresponds to an optimization enforced in the EVM. The compile in Solidity checks if any of the functions in the smart contract are payable, adding the check at the top of the <code>_dispatcher</code> method if no functions are found, rather than adding this check to each individual function.</p>
<p>Including the <code>msg.value</code> check at the top of the <code>_dispatcher</code> method helps to save gas, as the check is only performed once, rather than on each individual function.</p>
</blockquote>
<p>Assuming <code>msg.value</code> is zero, the next basic block to be executed will compare if <code>CALLDATASIZE</code> (<code>msg.data.size</code>)is less than <code>0x4</code>. If so, it will jump to <code>0x7d</code>, which is the <code>_fallback()</code> function that will <code>REVERT</code> the contract. This is another common behavior enforced by the EVM, as Solidity uses the first 4 bytes of the call data to select which function needs to be executed, and if no function is specified the fallback method will be called, as shown below:</p>
<figure><img src="../images/sc-re-2.png"
         alt="Figure 7 - Fallback implementation"/><figcaption>
            <p>Figure 7 - Fallback implementation</p>
        </figcaption>
</figure>

<p>Moving forward within the <code>_dispatcher()</code> implementation, the next thing we observe is that our basic block branches off into two different paths:</p>
<figure><img src="../images/sc-re-3.png"
         alt="Figure 8 - Dispatcher implementation"/><figcaption>
            <p>Figure 8 - Dispatcher implementation</p>
        </figcaption>
</figure>

<p>This is another optimization performed by the EVM, which instead of performing a linear function search, it splits the execution into two branches, and depending on the function selector provided it will perform the search in one branch or another.</p>
<p>This logic starts its implementation on address <code>0x21</code>, where the <code>PUSH4</code> opcode pushes 4 bytes (<code>0x423f6cef</code>) into the stack and then performs a comparison using the <code>GT</code> opcode. If the function selector provided by the user is lower than <code>0x423f6cef</code>, the execution flow will continue on address <code>0x5b</code>, otherwise it will continue on address <code>0x2b</code>.</p>
<p>Lets assume our selector hash is bigger than <code>0x423f6cef</code>, that means we will jump into the following basic block:</p>
<figure><img src="../images/sc-re-4.png"
         alt="Figure 9 - Selector jump"/><figcaption>
            <p>Figure 9 - Selector jump</p>
        </figcaption>
</figure>

<p>This is where the real logic behind the <code>_dispatcher</code> method is implemented, the <code>DUP1</code> opcode duplicates the first item in the stack, which is the hash of the function selector that we submitted to the contract (First 4 bytes of <code>msg.data</code>). The next instruction is <code>PUSH4 0x423f6cef</code>, which pushes those 4 bytes to the top of the stack. Then, it performs a comparison with the two items off the stack by using the <code>EQ</code> opcode (the first item will be <code>0x423f6cef</code>, and the second item will be the function selector), and pushing the result into the stack. Then it pushes <code>0xdc</code> into the stack by using <code>PUSH2 0xdc</code> (<code>safeTransfer(address, uint256</code>), and last but not least, it will use the opcode <code>JUMPI</code> to jump into the previous address, if the condition evalued by the <code>EQ</code> opcode was <code>true</code>. Otherwise it will continue execution at address <code>0x36</code>.</p>
<p>&ndash; Check this and write a better transition</p>
<p>The purpose of this contract is to exploit an integer underflow issue in the <code>unsafeTransfer</code> (<code>0xb9c13477</code>) function, but there is a peculiarity with this contract, as it has been compiled using Solidity 0.8.0.  In previous versions of Solidity (prior Solidity 0.8.0) an integer would automatically roll-over to a lower or higher number.</p>
<p>However, the <code>unsafeTransfer</code> method uses in its implementation the <code>unchecked</code> keyword, which allows developers write more
efficient programs. By default, smart contracts using Solidity 0.8.0 or higher implements a series of opcodes that prior to performing the actual arithmetic, check for under/overflow and revert the transaction if it is detected.</p>
<figure><img src="../images/sc-re-5.png"
          alt="Figure 10 - unsafeTransfer and safeTransfer methods&amp;rsquo; implementation"/><figcaption>
             <p>Figure 10 - unsafeTransfer and safeTransfer methods&rsquo; implementation</p>
         </figcaption>
 </figure>

<h3 id="spotting-the-issue">Spotting the issue</h3>
<p><strong>NTM</strong>: Write an introductory paragraph explaining how to use Remix
<strong>NTM</strong>: Why using remix and its debugger is benefitial for the successful exploitation of this vulnerability</p>
<h4 id="inspecting-the-safetransfer-method">Inspecting the safeTransfer method</h4>
<p><strong>NTM:</strong> Move this initial paragraph and modify the introduction to this section.</p>
<p>To identify the vulnerability lets compile and deploy the vulnerable smart contract with Remix, using <code>1000</code> tokens as initial supply. Then let&rsquo;s submit a <code>tx</code> to <code>safeTransfer</code> providing any address and <code>10000</code> as amount. The <code>tx</code> will automatically revert providing an error message, as shown below:</p>
<pre tabindex="0"><code>  
[vm]
from: 0x5B3...eddC4
to: MyToken.safeTransfer(address,uint256) 0xd91...39138
value: 0 wei
data: 0x423...02710
logs: 0
hash: 0xc48...5b4db
Debug
transact to MyToken.safeTransfer errored: VM error: revert.
revert
	The transaction has been reverted to the initial state.
Note: The called function should be payable if you send value and the value you send should be less than your current balance.
Debug the transaction to get more information.
</code></pre><p><strong>NTM:</strong> Add more information here</p>
<p>Debugging a <code>tx</code> in Remix can be tedious but necessary, as we will be able to step into and step back on each opcode, getting a better understanding on what&rsquo;s going on at a low level. But for now, let&rsquo;s just focus on the following opcodes and the stack values:</p>
<figure><img src="../images/sc-iu-safetransfer.png"
         alt="Figure 11 - safeTransfer opcodes step by step"/><figcaption>
            <p>Figure 11 - safeTransfer opcodes step by step</p>
        </figcaption>
</figure>

<p>This block  implements the logic that checks if <code>senderBalance</code> is less than <code>_value</code> by:</p>
<ol>
<li><code>SWAP3</code> swaps the top of the stack with the 4th last element (In this case the stack will remain the same).</li>
<li><code>POP</code> pops a uint256 off the stack and discards it.</li>
<li><code>DUP3</code> clones the third last value on the stack. As this operation is executed twice, it will add <code>0x0000000000000000000000000000000000000000000000000000000000002710</code> first, and then <code>0x00000000000000000000000000000000000000000000000000000000000003e8</code>, therefore the stack will look like this:</li>
<li><code>LT</code> (lower than, <code>a &lt; b</code>) performs a <code>uint256</code> comparison between the last two elements in the stack. In this case it will compare  <code>0x00000000000000000000000000000000000000000000000000000000000003e8 &lt; 0x0000000000000000000000000000000000000000000000000000000000002710</code>, returning <code>1</code>.</li>
<li><code>ISZERO</code> checks that the last element in the stack is <code>0</code> and pushes the result into the stack:</li>
<li><code>PUSH2 06e6</code> pushes a 2-byte value (<code>0x06e6</code>) into the stack:</li>
<li><code>JUMPI</code> conditional jump if condition is truthy, which in this case it is not</li>
<li><code>PUSH2 06e5</code> and <code>PUSH 07ab</code> which will add new elements into the stack:</li>
<li><code>JUMP</code> tells the EVM to have the instruction pointer jump to another location in the bytecode, by getting the location off the first value from the stack. It is worth mentioning that only offsets where the <code>JUMPDEST</code> opcode is located are considered valid jumping targets.</li>
</ol>
<p>This last opcode will move the execution flow to the address <code>0x7ab</code>, causing the transaction to revert with return data (<code>REVERT</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">1963</span> JUMPDEST
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1964</span> PUSH32 4e487b7100000000000000000000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1997</span> PUSH1 <span style="color:#ae81ff">00</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1999</span> MSTORE
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2000</span> PUSH1 <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2002</span> PUSH1 <span style="color:#ae81ff">04</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2004</span> MSTORE
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2005</span> PUSH1 <span style="color:#ae81ff">24</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2007</span> PUSH1 <span style="color:#ae81ff">00</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2009</span> REVERT
</span></span></code></pre></div><p>This is caused because the value submitted in our <code>tx</code> is larger than the funds available in the contract, which may cause an integer underflow.</p>
<h4 id="inspecting-the-unsafetransfer-method">Inspecting the unsafeTransfer method</h4>
<p>As we did in the previous step, this time we will submit a <code>tx</code> to the <code>UnsafeTransfer</code> method and focus on the <code>SUB</code> opcode and how it  handles the result, using the debugger available in Remix for that.</p>
<p>To speed up the process, the following opcodes are a snapshot of what occurs when executing <code>_balances[msg.sender] = senderBalance - value</code> inside an <code>unchecked</code> block:</p>
<figure><img src="../images/sc-iu-unsafetransfer.png"
         alt="Figure 12 - unsafeTransfer opcodes step by step"/><figcaption>
            <p>Figure 12 - unsafeTransfer opcodes step by step</p>
        </figcaption>
</figure>

<ol>
<li>The balance of the address (<code>0xAb8...35cb2</code>) that performs the <code>tx</code> has a total balance of <code>0</code>. The first last value in the stack is <code>0x2710</code> (<code>10000</code>) which corresponds to the funds currently available in the smart contract. The second last value in the stack contains our accont&rsquo;s balance, which is <code>0</code>.</li>
<li>The opcode <code>DUP2</code> clones the second last value on the stack (<code>0x0</code>).</li>
<li><code>SUB</code> performs a uint256 substraction modulo using the first and second last values on the stack (<code>0x0 - 0x2710</code>). This is where the integer underflow occurs.</li>
<li>The result of the previous opcode returns <code>0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f0</code>, this is because we have attempted to make a <code>uint256</code> negative, triggering the underflow and causing it to contain a high value instead.</li>
<li>The following opcodes corresponding to the instruction <code>_balances[_to] += _value;</code> will just set the new value as our current balance.</li>
</ol>
<h3 id="exploiting-the-smart-contract">Exploiting the smart contract</h3>
<p>So you have made it to this point and you may wonder how can you exploit the vulnerability that you just spotted. To achieve this goal we will use hardhat, an Ethereum development environment. Explaining how to setup the environment and how it does work is beyond this article, but I strongly recommend you to visit the following resources:</p>
<ul>
<li><a href="https://hardhat.org/docs"  target="_blank" rel="noopener" >Hardhat Documentation</a></li>
<li><a href="https://hardhat.org/tutorial"  target="_blank" rel="noopener" >Hardhat Tutorial</a></li>
</ul>
<p>Assuming you already have a working environment, we will divide our exploit in two separate files, <code>script.js</code></p>

    </article>
  </div>

</div>


  </div>
<script type="text/javascript" src="/main.js" defer></script>


</body>

</html>